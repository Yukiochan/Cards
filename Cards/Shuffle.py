''' Shuffle.py - simulates deck shuffling on arbitrary lists:
Pure RNG deck shuffling in computer card games is probably more
random than physical shuffling, but since humans are not good
at determining randomness, they can often seem less random to
players. This package simulates what physical shuffling is like
to try to create a more pleasing shuffling experience.
'''

import random


def cut(lst):
    '''Takes in a list, lst as an argument and returns a tuple in
    the form (first half,second half) where
    first_half + second_half = lst. The place where the list is
    split is determined by choosing from the random distribution
    of 3/8ths the list's lenghth and 5/8ths the list's length'''
    assert isinstance(lst, list)
    random.seed()
    p25 = len(lst) * 3 // 8
    p75 = len(lst) * 5 // 8
    split = random.randint(p25,p75)
    return (lst[:split],lst[split:])




'''The following two methods are supposed to simulate a very
particular pattern used when humans shuffle a deck. The deck is
first cut roughly in half. Then the top half is then cut roughly
in half. The bottom of the top half is placed below the bottom of
the original. The process is then repeated on the remaining cards
n times.'''

def n_cut(lst, n):
    '''Takes a list, lst and a positive integer, n as input and
    returns a tuple in the form (1st,2nd...nth) where 
    1st is the second half of cutting the first time, and the
    ith is the second half of cutting the top half of thei-1th.'''
    assert isinstance(lst, list)
    assert isinstance(n,int)
    assert n > 0
    top, bottom = cut(lst)
    result = [top]
    for _ in range(0,n):
        top, bottom = cut(bottom)
        #for testing
        #print(top,bottom)
        result.append(top)
    result.append(bottom)
    return tuple(result)

def n_cut_shuffle(lst, n):
    '''Takes a list, lst, and a positive integer, n and then
    performs an n_cut. Returns the list generated by returning
    the values in n_cut backwards'''
    assert isinstance(lst, list)
    result = []
    for lst in reversed(n_cut(lst,n)):
        result += lst
    return result

def double_cut_shuffle(lst):
    '''Special case of n_cut_shuffle where the list is first cut
    two times.'''
    return n_cut_shuffle(lst,2)

def triple_cut_shuffle(lst):
    '''Special case of n_cut_shuffle where the list is first cut
    three times.'''
    return n_cut_shuffle(lst,3)




def bridge(lst,up):
    '''Simulates a bridge shuffle. Takes a list, lst and a bool, up
    and simulates a bridge by splitting the deck roughly in two and
    randomly taking 1-3 elements from each stack to build a new deck.
    The bool, up, determines whether the top card at the end of the
    shuffle came from the top deck or the bottom deck'''
    assert isinstance(lst, list)
    assert isinstance(up, bool)
    random.seed()
    result = []
    top_stack, bottom_stack = cut(lst)
    top_iter, bottom_iter = 0,0 # keep track of where we are in each stack
    while top_iter <= len(top_stack) and bottom_iter <= len(bottom_stack):
        new_top = top_iter + random.randint(1,4)
        new_bottom = bottom_iter + random.randint(1,4)
        if up:
            # top stack gets added first
            result += top_stack[top_iter:new_top]
            result += bottom_stack[bottom_iter:new_bottom]
            top_iter, bottom_iter = new_top, new_bottom
        else:
            # bottom stack gets added first
            result += bottom_stack[bottom_iter:new_bottom]
            result += top_stack[top_iter:new_top]
            top_iter, bottom_iter = new_top, new_bottom
    if top_iter <= len(top_stack): # one of our stacks is depeted
        result += top_stack[top_iter:]
    else:
        result += bottom_stack[bottom_iter:]
    return result;





def shuffle_sequence(lst):
    '''takes a list, l, and preforms 4 triple_cut_shuffles
    and 2 bridges, returning a new shuffled list'''
    assert isinstance(lst, list)
    random.seed()
    result = lst
    for _ in range(0,4):
        result = triple_cut_shuffle(result)
    for _ in range(0,2):
        up = bool(random.randint(0,1))
        result = bridge(result,up)
    return result

def realistic_shuffle(lst):
    '''preforms the shuffle_sequence 6 times, returning
    the resultant list'''
    result = lst
    for _ in range(0,6):
        result = shuffle_sequence(result)
    return result;


#for testing
#lst = list(range(0,52))
#print(realistic_shuffle(lst))